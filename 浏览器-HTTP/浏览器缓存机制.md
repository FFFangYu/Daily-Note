# 浏览器缓存机制

## 过程（以谷歌主页为例）

### 第一次请求

![第一次请求](D:\我的资料\前端笔记\Daily-Note\浏览器-HTTP\assets\第一次请求.png)
![第一次请求](https://github.com/FFFangYu/Daily-Note/blob/master/浏览器-HTTP/assets/第一次请求.png)

第一次请求，肯定是没有缓存的，这时候，服务器会告诉浏览器他的缓存机制，当然是通过一些字段来告知。

上图，明显返回了cache-control、expires字段。

### 第二次请求

![第二次请求](D:\我的资料\前端笔记\Daily-Note\浏览器-HTTP\assets\第二次请求.png)
![第二次请求](https://github.com/FFFangYu/Daily-Note/blob/master/浏览器-HTTP/assets/第一二次请求.png)

**🍭强缓存**

这一次请求，就需要我们询问是否有缓存了，从响应状态200（from memory cache）可以看出，此次缓存从内存中获取。

首先获取该资源缓存的header信息判断是否命中强缓存，发现cache-control和expires字段，属于强缓存。通过缓存方案来判断是否命中缓存。因为Cache-Control优先级高与Expires，所以判断Cache-Control即可。

**缓存方案**

Expires：response headder里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中缓存。

Cache-Control：当值设为max-age=300时，则表示在这个请求正确返回时间（浏览器也会记录下来）的5分钟内会再次加载资源，就会命中缓存。

**两者缓存方案的区别：**

- 首先优先级的差别
- 其次Expires是HTTP/1的产物，有着一些缺陷。因为使用的是过期时间，所以如果修改了本地时间可能会造成缓存的失效。另外如果服务器和浏览器的时间不一致，那么服务器返回的这个过期时间就是不准确的。



**🍭协商缓存**

如果缓存过期了，那么就需要向服务器发起请求，询问资源有没有过期。如果服务器给出304，表明资源没有过期可以使用缓存，并且会给出浏览器缓存有效期。

协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。

**⭕Last-Modified 和 If-Modified-Since**

Last-Modified 表示本地文件最后修改日期，If-Modified-Since 表示服务器传来的最后修改时间，会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码，告诉浏览器直接使用缓存。

但是 Last-Modified 存在一些弊端：

- 如果**本地打开缓存文件**，即使没有对文件进行修改，但还是会造成     Last-Modified 被**修改**，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能**以秒计时**，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

因为以上这些弊端，所以在 HTTP / 1.1 出现了 ETag 。

**⭕ETag 和 If-None-Match**

ETag 类似于文件指纹（文件的唯一标识），If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来，否则返回304，直接使用缓存。并且 ETag 优先级比 Last-Modified 高。

**两者对比（Last-Modified、ETag）**

1. 在精准度上，ETag优于Last-Modified。优于     ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified     就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:

2. - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
   - Last-Modified      能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

3. 在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而     Etag需要根据文件的具体内容生成哈希值。



## 浏览器缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache
5. 网络请求

**🔴Service Worker**

让JS运行在主线程之外，由于它脱离浏览器的窗体，因此无法直接访问DOM。虽然如此，但还是可以完成很多功能，比如**离线缓存**、**消息推送**和**网络代理**。

Service Worker的缓存与浏览器其他内建的缓存机制不同，它可以让我们**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存、并且**缓存是持续性**的。

当Service Worker没有命中缓存的时候，我们需要去调用fetch函数获取数据。也就是说，如果没有命中，会根据缓存查找优先级去查找数据。但是不管我们从**Memory Cache**还是从网络请求中获取数据，浏览器都会显示从**Service Worker**中获取数据。

**🔴Memory Cache（内存缓存）**是内存中的缓存，读取内存中的数据肯定比磁盘快。但是**内存缓存虽然读取高效，但缓存持续性短，会随着进程的释放而释放**。意味着你一旦关闭Tab页面，内存中的缓存也就释放了。

当我们访问过页面，再次刷新页面的时候，可以发现很多数据都来自于内存缓存。

虽然内存缓存很高效，但是我们不能让数据都存放在内存之中。因为计算机的内存比起硬盘的容量要小得多，操作系统需要精打细算内存的使用，所以我们可以使用的内存必然不多。

**🔴Disk Cache（硬盘缓存）**是存储在硬盘之中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比起内存缓存**胜在容量和存储时效性上**。

在所有浏览器缓存中，Disk Cache覆盖面基本是最大。它会根据**HTTP Header**中的字段判断**哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘存储下来，就不会再次去请求数据。

比较大的JS、CSS文件会直接丢尽磁盘，反之，丢进内存

内存使用率较高的时候，文件优先进入磁盘

**🔴Push Cache（推送缓存）**是HTTP/2中的内容，当以上三种缓存都没有命中，它才会使用。并且缓存时间很短暂，只在会话中存在，一旦会话结束就会被释放。

**🔴网络请求**，当所有缓存都没有命中，那么只能发起请求来获取资源。为了性能上的考虑，大部分接口都应该选择好缓存策略。