## 宏任务

在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:

1. 渲染事件
2. 用户交互事件
3. js脚本执行
4. 网络请求、文件读写完成事件等等。

为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种**队列的方式来存储**这些任务， 即先进来的先执行。

## 微任务

**对于每个宏任务而言，其内部都有一个微任务队列**。**那为什么要引入微任务？微任务在什么时候执行呢？**

其实引入微任务的初衷是**为了解决异步回调**的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:

1. 将异步回调进行宏任务队列的入队操作。
2. 将异步回调放到当前宏任务的末尾。

如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成**应用卡顿**。

为了规避这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个**微任务队列**，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。

**常见的微任务**有**MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程**。

## 浏览器中的事件循环

🅰总结流程：

1. 一开始整段脚本作为第一个**宏任务**执行
2. 执行过程中同步代码直接执行，**宏任务**进入宏任务队列，**微任务**进入微任务队列
3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有Web   worker任务，有则执行
6. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

## Nodejs中的事件循环

![nodejs](D:\我的资料\前端笔记\Daily-Note\浏览器-HTTP\assets\nodejs.png)
![nodejs](https://github.com/FFFangYu/Daily-Note/blob/master/浏览器-HTTP/assets/nodejs.png)

**三大关键阶段**

首先，梳理一下 nodejs 三个非常重要的执行阶段:

1. 执行 **定时器回调** 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它**timer**。
2. **轮询(英文叫poll)阶段**。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过'data'、 'connect'等事件使得事件循环到达 poll 阶段。到达了这个阶段后:

如果当前**已经存在定时器**，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。

如果**没有定时器**, 会去看回调函数队列。

- 如果队列不为空，拿出队列中的方法依次执行

- 如果队列为空，检查是否有 setImmdiate 的回调 

- - 有则前往check阶段(下面会说)
  - 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的),      等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。

3. **check 阶段**。这是一个比较简单的阶段，**直接执行 setImmdiate 的回调**。

这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。

**完善**

首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。

并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， 'close' 事件的回调就会在这个阶段执行。

梳理一下，**nodejs 的 eventLoop 分为下面的几个阶段**:

1. timer 阶段
2. I/O 异常回调阶段
3. 空闲、预备状态(第2阶段结束，poll  未触发之前)
4. poll 阶段
5. check 阶段
6. 关闭事件的回调阶段

另外 **node** **版本** **>= 11的，它会和浏览器表现一致**，一个定时器运行完立即运行相应的微任务。

而 **node** **版本小于** **11** 的情况下，对于定时器的处理是:

若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。



**Nodejs和浏览器关于EventLoop的主要区别**

两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。

**process.nextTick的一点说明**

process.nextTick 是一个独立于 eventLoop 的任务队列。

在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。

