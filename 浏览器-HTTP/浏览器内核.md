## JS引擎为什么是单线程？

JS最开始就是为了浏览器而生，如果做成异步，那么在操作DOM的时候会产生很多问题，比如某个元素还没有被添加到DOM树中，却已经开始试图去操作了。

JS执行时间过长会造成页面阻塞，后来HTML5中支持Web Worker来处理cpu密集型计算。

## 进程和线程

将两者看作工厂和工人，每家工厂可以有一到多个工人，每家工厂的工人负责自己工厂内的生产。

- 进程是CPU资源分配的最小单位
  - 拥有自己的资源（独立的内存空间）
  - 由一到多个线程组成
  - 进程之间相互独立
- 线程是CPU调度的最小单位
  - 一个进程内的线程共享资源（代码段、数据集、堆等）
  - 多个线程在进程中协作完成任务

## 浏览器是多进程的

浏览器的进程可以看作是Tab页面，一个Tab页面一个进程。

**浏览器多进程的优势：**

- 避免单page crash影响整个浏览器
- 避免第三方插件崩溃影响整个浏览器
- 多进程可以充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

当然，内存的资源消耗也会更大。

### 浏览器多进程的组成

1. 浏览器进程（有且只有一个，负责协调和主控）
   1. 负责界面的显示，与用户交互。如前进、后退
   2. 负责各页面的管理，创建和销毁其他进程
   3. 将Render进程得到的内存中Bitmap，绘制到用户界面上
   4. 网络资源的管理和下载等
2. 浏览器渲染进程（浏览器内核，内部多线程）
   1. 作用：页面渲染，脚本执行，事件处理。
3. GPU进程（一个）
   1. 多用于3D绘制
4. 网络进程（一个）
   1. 负责页面的网络资源加载
5. 插件进程（每个类型的插件对应这一个进程）
   1. 主要负责插件的运行，因为插件易崩溃，所以用插件进程进行隔离。

## 浏览器内核（渲染进程）

浏览器的渲染进程是多线程的，包括：

- GUI渲染线程
  - 负责渲染浏览器界面，解析HTML、CSS构建DOM树和Render树，布局和绘制。
  - 当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
  - 注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时，GUI线程会被挂起，GUI更新会被保存在一个队列中等JS引擎空闲再执行。
- JS引擎线程
  - 也称JS内核，负责处理JavaScript脚本程序。（例如V8引擎）
  - JS引擎线程负责解析JavaScript脚本，运行代码。
  - 注意：JS引擎线程与GUI渲染线程互斥，所以，如果JS执行时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。
- 事件触发线程
  - 用来控制事件循环
  - 当JS引擎执行代码时，会将对应的任务（setTimeout、Ajax、鼠标点击...）添加到事件线程中，当事件被触发时，事件线程会把事件添加到待处理事件队列的队尾，等待JS引擎的处理。
- 定时触发器线程
  - 定时器所在线程
  - 浏览器中定时计数器，不由JS引擎计数，因为JS引擎是单线程，如果处在阻塞状态，会影响计数结果。
  - 因此，通过单独线程计时并触发定时（计时完毕，添加到事件队列中，等待JS引擎空闲后执行）。
  -  W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 
- 异步HTTP请求线程
  - 用于处理请求XHR，在连接后是通过浏览器新开一个线程请求。
  -  将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。 

## 浏览器进程和浏览器渲染进程的通信？

- 浏览器进程收到用户请求，首先获取页面的内容，随后将该任务通过RendererHost接口传递给Render进程
- 渲染进程的Renderer接口收到消息，简单解释后，将内容交给GUI渲染线程，然后开始渲染
  - GUI渲染线程接收到请求，加载网页并渲染网页，其中可能需要浏览器进程获取资源和GPU进程来帮助渲染
  - 当然，这里面JS引擎线程可能会来操作DOM（造成回流并重绘）
  - 最后渲染进程将结果传递给Brower进程
- 浏览器进程接收到结果并将结果绘制出来



## load事件和DOMContentLoaded事件

- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)
- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）

所以，DOMContentLoaded先于onload