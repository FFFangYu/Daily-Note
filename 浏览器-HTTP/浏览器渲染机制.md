## 先说一下什么是重绘什么是回流？

**🍭回流（重排）**

**触发条件（布局）**

- 一个DOM元素的几何属性发生变化，常见的几何属性有with、height、padding、margin、left、top、border等等
- 使DOM节点发生增减或移动
- 读写offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作
- 调用window.getComputedStyle方法

**回流过程**

触发回流的时候，如果DOM结构发生变化，则重新渲染DOM树，然后将后面的流程（包括主线程之外的任务）全部走一遍。相当于将解析和合成的过程重新走一遍，开销十分大。

 

**🍭重绘**

**触发条件（样式）**

当DOM的修改导致了样式的变化，并没有影响到几何属性的时候，会发生重绘。

**重绘过程**

由于没有导致DOM几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。可以知道的是，重绘不一定导致回流，但是回流一定会发生重绘。

![重绘回流](D:\我的资料\前端笔记\Daily-Note\浏览器-HTTP\assets\重绘回流.png)

**🍭合成**

比如CSS3的transform、opacity、filter这些属性可以实现合成效果，也就是常说的GPU加速。

**GPU加速的原因**

在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理，好处有：

- 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进程加速生成，而GPU是擅长处理位图数据的
- 没有占用主线程的资源，即使主线程卡住，效果依然十分流畅的显示

## 再说一下从输入url到网页显示发生了什么？

### 🔴网络请求部分

假设，在浏览器中输入百度的网址：

**⭕网络请求**

1. 浏览器会构建请求（行）

2. 查找强缓存，先检查强缓存，如果命中直接使用，否则进行下一步

3. DNS解析。因为输入的是域名，而数据包是通过IP地址传给对方，因此需要得到域名对应的IP地址。

4. 建立TCP连接

5. 1. 三次握手
   2. 数据传输
   3. 四次挥手

6. 发送HTTP请求

7. 1. 请求行

   2. 请求头

   3. 1. Cache-Control
      2. If-Modified-Since
      3. If-None-Match

   4. 请求体

   5. 1. 只有POST方法存在
      2. 常见场景：表单提交

**⭕网络响应**

HTTP请求到达服务器，服务器进行对应的处理。最后把数据传给浏览器，也就是返回网络响应。

- 响应行（HTTP协议版本+状态码+状态描述）

- 响应头

- - 包含服务器及其返回数据的一些信息，服务器生成数据的时间、返回数据类型以及对即将写入的Cookie信息

- 响应体

响应完成之后，就要断开TCP连接嘛？不一定，这时候要判断Connection字段，如果请求头或响应头中包含Connection：keep-alive表示建立持久连接，这个TCP会一直保持，之后请求统一站点的资源会复用这个连接。

完成网络请求和响应，如果响应头中Content-type值为text/html，那么接下来就是**浏览器解析和渲染**工作。

### 🔴浏览器渲染部分

前面重绘回流部分，有一张图，其实就是浏览器渲染的过程。

**1、构建DOM树**

- 标记化（词法分析）
- 建树（语法分析）

**2、样式计算**

- 格式化样式表

- 标准化样式属性

- 计算每个节点的具体样式

- - 继承
  - 层叠

**3、生成布局树**

- 遍历生成的DOM树节点，并把它们添加到布局树中
- 计算布局树节点的坐标位置

注意的是，这棵布局树**只包含可见元素**，对head标签和设置display：noe的元素，不会放入其中。

**4、建立图层树**

考虑到一些复杂的场景，比如3D动画呈现变换效果，当元素含有层叠上下文时如何让控制显示和隐藏等等，在浏览器构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树。

一般情况下，节点的图层会默认属于父节点的图层（合成层），那么什么时候会提升为 一个单独的合成层？

- 显式合成

- - 拥有层叠上下文的节点

  - - HTML根元素本上就具有层叠上下文
    - 普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文
    - 元素的opacity值不是1
    - 元素的transform值不是none
    - 元素的filter值不是none
    - 元素的isolation值不是isolate
    - will-change指定的属性值为上面任意一个。

  - 需要剪裁的地方

  - - 比如一个div，你只给他设置       100 * 100       像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。

- 隐式合成

- - 简单来说就是**层叠等级低的节点**被提升为单独的图层之后，那么所有**层叠等级比它高的节点**都会成为一个单独的图层。
  - 这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个z-index比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是层爆炸的原理。这里有一个具体的例子，点击打开。
  - 值得注意的是，当需要repaint时，只需要repaint本身，而不会影响到其他的层。

**5、生成绘制列表**

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。

**6、生成图块并栅格化**

现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫**合成线程**。

绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。

首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层**分块**。这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个**低分辨率**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

顺便提醒一点，渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**。

然后合成线程会选择视口附近的**图块**，把它交给**栅格化线程池**生成位图。

生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程。

**7、显示器显示内容**

栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。

浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。

看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。



😭当然上面内容是搜到的一些资料，下面记录下自己的理解：

简单来说，当我们网络请求响应后，得到一系列的html、js、css文件后，会将渲染任务交给渲染进程。浏览器内核拿到资源后，渲染分为：

- 首先先将html转为DOM树（结构信息），css转为cssOM树（样式信息），

- 后面将这两棵树计算得到一颗render树，此时这棵树就包含了结构以及样式。

- 然后生成布局树（layout/reflow），实现各元素尺寸、位置的计算。

- 最后，浏览器将各层（前面应该有建立图层树）的信息发送各GPU，GPU将各层合层composite，显示再屏幕上。