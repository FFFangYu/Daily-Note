## 跨域

浏览器出于安全考虑，有同源策略，也就说，如果协议、域名或者端口有一个不同就是跨域，Ajax请求会失败。

#### **❓那么是出于什么考虑会引入这种机制？**

主要用来防止CSRF攻击。简单点来说，CSRF攻击是利用用户的登录态发起恶意攻击。

也就是说，没有同源策略的情况下，A网站可以被任意其他来源的Ajax访问到内容。如果你当前A网站还存在登录态，那么对方就可以通过Ajax获取到你的任意信息。当然跨域并不能完美解决CSRF。

 

#### **❓那么，请求跨域了，请求到底发出去没？**

请求当然发出去了，但是浏览器拦截了响应。你可能会疑问明明通过**表单的方式可以发起跨域请求**，为什么 Ajax 就不会。因为归根结底，**跨域是为了阻止用户读取到另一个域名下的内容**，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。



#### **解决跨域问题的方法：**

- JSONP

  - 利用<script>标签没有跨域限制的漏洞。通过<script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。

- ⭕CORS

  - CORS需要浏览器和后端同时支持。IE8和9需要通过XDomainRequest来实现。

    浏览器会自动进行CORS通信，需要CORS通信的关键是后端。只要后端是实现了CORS，就实现了跨域。

  - 服务端设置**Access-Control-Allow-Origin**就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

- document.domain

  - 只能用于**二级域名相同**的情况下，比如a.test.com和b.test.com适用于该方式。

    只需要给页面添加document.domain = 'test.com'表示是二级域名相同就可以实现跨域。

- postMessage

  - 通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。

> 然后详细说下**CORS**中客户端的两种请求方法

**简单请求**

条件：

- 使用方法之一：GET、HEAD、POST
- Content-Type的值是其中一个：text/plain、multipart/form-data、application/x-www-from-utlencoded

请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问。

**复杂请求**

不符合简单请求要求的即为复杂请求。对于复杂请求来说，首先会发起一个**预检请求**，该请求是**option**方法的，通过该请求来知道服务端是否允许跨域请求。