# 数据类型

这一部分一共分为四块内容：

- 数据类型
- 类型检测
- 类型转换
- 数据存储

## 数据类型

### 值类型（基本数据类型、原始类型）

- Null
  - 空对象指针
  - ✔问题：`typeof null == ‘object’`
  - ✔问题：`Null和Undefined的区别？`
- Undefined
- String
  - ✔涉及：`'1'.toString()`
- Number
  - ✔涉及：`0.1+0.2 === 0.3`的问题
- Boolean
- Symbol
- BigInt

> typeof null == ‘object’

答：在使用typeof null的时候会输出object，所以会认为null是个对象类型，然而并不是。出现bug的问题是因为，在JS中最初使用32位系统，为了性能考虑使用低位存储遍历的类型信息，000开头代表对象，然后null表示为全零，这就造成了误判。

> Null和Undefined的区别？

答：一般来说，一个变量只声明不赋值，默认变量的值是undefined。所以，无论在什么情况下，都没有必要把一个值显示的设置为undefined。

而null值表示一个空对象指针，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。

另外，undefined派生自null，所以undefined==null输出为true

> '1'.toString()

答：'1'已经不是原始类型了，已经被强制转换成了String类型也就是对象类型，所以可以调用toString函数。

> 0.1+0.2 === 0.3`的问题

答：number类型是浮点类型，在使用中会遇到0.1+0.2!==0.3。这是因为，在JS中使用的是双精度（64位），像0.1这样的十进制用二进制表示是无限循环的，但是JS采用的 浮点数标准会剪裁数字，就会出现精度丢失的问题，也就造成了0.1不再是0.1了。

- 可以通过原生的方式解决：parseFloat((0.1     + 0.2).toFixed(10)) === 0.3 

### 引用类型（复杂数据类型、对象类型）

JS中除了值类型，那么其他的都是引用类型。和值类型存储值不同的是，引用类型存储的是地址（指针）。当你创建一个引用类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

`Object`

- Function
  - arguments
- Date
- Array
  - 常用的API
- Math
- RegExp

## 类型检测

### typeof

- 对于原始类型来说，除了null都可以显示正确的类型
- 对于对象来说，除了函数都会先显示object
- 所以说，typeof并不能准确判断变量的类型

### instanceof

- 判断对象的正确类型，内部机制是通过原型链来判断。
- 对于原始类型的判断，可以通过Symbol.hasInnstance来实现（Symbol.hasInstance用于判断某对象是否为某构造器的实例。）

> Object.is和===的区别

答：+0和-0、NaN和NaN，Object.is在===的基础上修复了这个问题

```js
function object_is(x,y){
    if(x===y){
        // +-0
        return x!==0||y!==0||1/x===1/y
    }else{
        return x!==x&&y!==y
    }
}
console.log(object_is(+0,-0))
```

## 类型转换

JS中类型转换只有三种情况，分别是：

- 转换为布尔值
- 转换为数字
- 转换为字符串

**`==`和`===`的区别**

===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等。

对于==来说，如果上方的类型不一样的话会进行类型转换。

假设需要对比x和y是否相同，**判断流程**如下：

1. 首先判断两者类型是否相同。相同的就比较大小
2. 类型不同，就会发生类型转换
3. 先判断是都在对比null和undefined，是的话就返回true
4. 判断两者类型是都为string和number，是的话就将字符串转换为number
5. 判断其中一方是否为boolean，是的话把boolean转为number再判断
6. 判断其中一方是否为object且另一方为string、number后者symbol，是的话就会把object转为原始类型再判断。[object 类型]

✔常见问题：

> **[]==![]**

答：

- 左右两边都需要转为数字再做比较
- []转为数字为0
- ![]首先转为一个布尔类型，由于[]作为一个引用类型转为布尔类型为true，因此![]为false，转为数字为0
- 0==0，结果为true

**对象转原始类型根据什么流程运行？**

对象转原始类型，会调用内置的**[ToPrimitive]函数**，对于该函数而言，其逻辑如下：

1. 如果Symbol.toPrimitive()方法，优先调用再返回
2. 调用valueOf()，如果转换为原始类型，则返回
3. 调用toString()，如果转换为原始类型，则返回
4. 如果都没有返回原始类型，会报错

## 数据存储

**基础数据类型用栈存储，引用数据类型用堆存储。**

但是如果考虑闭包，变量存在栈中，那回调函数用完栈顶空间销毁，闭包变量就没有了吗？

**闭包变量是存在堆内存的。**

具体而言，以下数据类型存储在栈中：

- boolean
- null
- undefined
- number
- string
- symbol
- bigint

而所有对象数据类型存放在堆中。

对于**赋值操作**，原始数据类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。

**为什么不全部用栈来保存？**

首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。

总结：如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大。堆内存虽然空间大，能存放大量数据，但于此同时垃圾回收带来更大的开销！

