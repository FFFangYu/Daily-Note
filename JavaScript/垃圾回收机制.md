## 垃圾回收机制（分代式）

### V8内存限制

对于栈内存来说，ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言，我们知道，所有对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断这样创建对象，让v8为它分配空间，直到堆的大小达到上限。

**❓那么，V8为什么要设置内存上限？**

由**两个因素**共同决定：

- JS单线程的执行机制

- - 这意味随着一旦进入垃圾回收，那么其他的各种运行逻辑都要暂停。

- JS垃圾回收机制的限制

- - 垃圾回收其实非常耗时，如果长时间内，JS代码执行一直没有相应，会造成应用卡顿，导致应用性能和响应能力直线下降。

### 垃圾回收机制

V8实现准确式GC，GC算法采用了**分代式**垃圾回收机制。因此，V8将内存（堆）分为新生代和老生代两部。

**🅰新生代算法（临时分配的内存）**

**内存默认限制**：64位和32位分别为32MB和16MB

新生代中对象的**存活时间较短**，使用Scavenge GC算法。

在新生代空间中，内存空间分为两个部分，分别是**From**空间和**To**空间。

其中**From部分**表示正在使用的内存，**To** 是目前闲置的内存。

当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(**在To内存中按照顺序从头放置的**)，如果是非存活对象直接回收即可。

当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。

那你很可能会问了，**直接将非存活对象回收了不就万事大吉了嘛**，为什么还要后面的一系列操作？

注意，我刚刚特别说明了，在To内存中**按照顺序从头放置**的，这是为了应对**内存碎片**。

不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

**🅱老生代算法（常驻内存）**

老生代中的对象一般**存活时间较长且数量也多。**（**标记清除算法**+**标记压缩算法**）

先来说说什么情况下的对象会出现在老生代空间中：（新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫**晋升**。）

- 新生代中的对象是否已经经历一次Scavenge算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- To空间的对象占比大小超过25%。这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

**❓那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？**

第一步，**进行标记-清除**。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即*标记阶段和清除阶段*。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。

当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？

第二步，**整理内存碎片**。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。

由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最**耗时**间的部分。

为解决这个问题V8从stop-the-world标记切换到**增量标记**。在增量标记期间，GC将标记工作分为更小的模块，可以让JS应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿。之后，又有一项重大突破，并发标记，可以让GC扫描和标记对象时，同时允许JS运行。

最后，**清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。**在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。