### 响应式原理

**面试必备问题**

简单来说，就是数据模型仅仅是普通的Javascript对象，但是当你修改他们的时候，视图会进行响应的更新。

#### 数据劫持+发布订阅

一个vue实例中有个data选项，里面存储着这个组件的数据。vue将遍历该选项中所有property，并使用Object.defineproperty，重写里面的getter/setter方法。（这些getter/setter对用户是不可见的，但是在内部可以让vue追踪依赖，在property被访问和修改的时候通知变更）

每个组件实例都对应一个watcher实例，它会在组件渲染的过程中把接触过的数据的property记录为依赖。之后当依赖项的setter触发，会通知到watcher，从而使它关联的组件重新渲染。

#### 不能检测

- 对象的添加和移除
  - 通过vue.set(vm.someObject,'b',2)
- 数组通过索引设置和修改数组长度
  - Vue.set()或者vm.items.splice()方法解决索引设置
  - 通过splice方法修改数组长度

#### $nextTick()

Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。

如果同一个 watcher 被多次触发，只会被推入到队列中一次。 

这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 

有些时候，为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。  其实，在组件内使用 `vm.$nextTick()` 实例方法特别方便，因为它不需要全局 `Vue`，并且回调函数中的 `this` 将自动绑定到当前的 Vue 实例上 。